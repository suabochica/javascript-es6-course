
Next Generation JavaScript: Intro to EcmaScript 2015/ES6
========================================================

Before to start with the new standard of JavaScript we have to take attention to the next standard versions considerations:

1. ES5
    - Standard fully supported in all modern browser.
    - Ready to be used since 2016.
2. ES6/ES2015 
    - Standard partially supported in modern browsers, no support in older browsers.
    - Can't use it in production in 2016. You have to setup a transpiler.
3. ES2016, ES2017
    - Standard no support in morder browsers
    - Can't use it in production in 2016. You have to setup a transpiler.

Below a list with the ES6 feaures we will cover in this section:

- Variables Declarations with `let` and `const`
- Blocks and IIFEs
- Strings
- Arrow Functions (Maybe the most important feature)
- Destructuring
- Arrays
- The Spread Operator
- Rest and Default Parameters
- Maps
- Classes and subclasses
- How to use ES2015/ES6 today

Please check [the comparative table of the ES6 features supported by browser](http://kangax.github.io/compat-table/es6/).

Variable Declarations with `let` and `const`
--------------------------------------------

We can introduce the keywords `let` and `const` with comparative `var` examples:

```javascript
//ES5
var i = 21;

for(var i = 0; i > 5; i++) {
    console.log(i);
}

console.log(i); //-> 0, 1, 2, 3, 4, 5

//ES6

let j = 21;

for(let i = 0; j > 5; i++) {
    console.log(i); //-> 0, 1, 2, 3, 4, 5
}

console.log(j); //-> 21
```

As you can see, the outputs in the console are different when you use `let` variable declaration. That is due to the scope associated with each keyword. Now let's check an example with `const`;

```javascript
//ES5
function statalLicense5(passedTest) {
    if(passedTest) {
        var firstName = 'Edward Elric';
        var yearOfBirth = `1990`;
    }
    
    console.log(firstName + ', born in ' + + ', is now officially a statal alchemist')
}


//ES6
function statalLicense6(passedTest) {
    if(passedTest) {
        let firstName = 'Edward Elric';
        const yearOfBirth = `1990`;
        console.log(firstName + ', born in ' + + ', is now officially a statal alchemist')
    }
    
    // console.log(firstName + ', born in ' + + ', is now officially a statal alchemist') //-> Throw ReferenceError: firstName is not defined.
}
```

After this examples we have the next conclusions:

- Use `let` to define variables that will change his value (as indexes).
- Use `const` to define variables that will **not** change his value (as a year of birth).
- `let`and `const` are variables definitions block-scoped and `var` is function-scoped. A block is all the code wrapped by `{}`.
- You can't define a `const` var definition outside of the block where you will use the variable.
- `let`and `const` are variables with **temporal-dead zone**. This means that the variables are hoisted, but we still cannot access them before they are declared.

Blocks and IIFEs
----------------

The concept of **block-scoped** is related to data privacy. Remember that in ES5 we get data privacy through IIFEs. In ES6 we can cleanly define data privacy but we have to take care of some considerations. The next code is an example of data privacy in ES6 with block-scoped and his equivalent in ES5:

```javascript
//ES5

(function({
    var a = 1;
})();

console.log(a) //-> Uncaught ReferenceError.


//ES6
{
    let b = 2;
    const c = 3;
    var d = 4;
}

console.log(b + c) //-> Uncaught ReferenceError.
console.log(4); //-> 4
```

As you can see, if you try to access the de variables `b` and `c` out of the block-scope you will get a reference error. However, if you see the `d` variable we have access to it, and this is because we declare the variables using the `var` keyword, then the variable is function-scoped instead of block-scoped, allowing then the access to it.